package net.ccbluex.liquidbounce.features.module.modules.exploit;

import kotlin.jvm.functions.Function1;
import net.ccbluex.liquidbounce.api.minecraft.client.block.IBlock;
import net.ccbluex.liquidbounce.api.minecraft.client.network.IINetHandlerPlayClient;
import net.ccbluex.liquidbounce.api.minecraft.network.IPacket;
import net.ccbluex.liquidbounce.api.minecraft.network.play.client.ICPacketPlayer;
import net.ccbluex.liquidbounce.api.minecraft.util.IAxisAlignedBB;
import net.ccbluex.liquidbounce.api.minecraft.util.WBlockPos;
import net.ccbluex.liquidbounce.event.BlockBBEvent;
import net.ccbluex.liquidbounce.event.EventTarget;
import net.ccbluex.liquidbounce.event.MoveEvent;
import net.ccbluex.liquidbounce.event.PacketEvent;
import net.ccbluex.liquidbounce.event.PushOutEvent;
import net.ccbluex.liquidbounce.event.UpdateEvent;
import net.ccbluex.liquidbounce.features.module.Module;
import net.ccbluex.liquidbounce.features.module.ModuleCategory;
import net.ccbluex.liquidbounce.features.module.ModuleInfo;
import net.ccbluex.liquidbounce.utils.MovementUtils;
import net.ccbluex.liquidbounce.utils.block.BlockUtils;
import net.ccbluex.liquidbounce.utils.timer.TickTimer;
import net.ccbluex.liquidbounce.value.ListValue;

@ModuleInfo(
    name = "Phase",
    description = "Allows you to walk through blocks.",
    category = ModuleCategory.EXPLOIT
)
public class Phase extends Module {

    private final ListValue modeValue = new ListValue("Mode", new String[] { "Vanilla", "Skip", "Spartan", "Clip", "AAC3.5.0", "Mineplex"}, "Vanilla");
    private final TickTimer tickTimer = new TickTimer();
    private boolean mineplexClip;
    private final TickTimer mineplexTickTimer = new TickTimer();

    @EventTarget
    public void onUpdate(UpdateEvent event) {
        boolean isInsideBlock = BlockUtils.collideBlockIntersects(Phase.mc.getThePlayer().getEntityBoundingBox(), (block) -> {
            return Boolean.valueOf(!Phase.classProvider.isBlockAir(block));
        });

        if (isInsideBlock && !((String) this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            Phase.mc.getThePlayer().setNoClip(true);
            Phase.mc.getThePlayer().setMotionY(0.0D);
            Phase.mc.getThePlayer().setOnGround(false);
        }

        IINetHandlerPlayClient netHandlerPlayClient = Phase.mc.getNetHandler();
        String s = ((String) this.modeValue.get()).toLowerCase();
        byte b0 = -1;

        switch (s.hashCode()) {
        case -2011701869:
            if (s.equals("spartan")) {
                b0 = 2;
            }
            break;

        case 3056464:
            if (s.equals("clip")) {
                b0 = 3;
            }
            break;

        case 3532159:
            if (s.equals("skip")) {
                b0 = 1;
            }
            break;

        case 233102203:
            if (s.equals("vanilla")) {
                b0 = 0;
            }
            break;

        case 325230105:
            if (s.equals("aac3.5.0")) {
                b0 = 4;
            }
        }

        double yaw;
        double oldX;
        double oldZ;
        int i;

        switch (b0) {
        case 0:
            if (Phase.mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && Phase.mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || Phase.mc.getThePlayer().isSneaking())) {
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(0.5D, 0.0D, 0.5D, true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY() + 0.2D, Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(0.5D, 0.0D, 0.5D, true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX() + 0.5D, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + 0.5D, true));
                yaw = Math.toRadians((double) Phase.mc.getThePlayer().getRotationYaw());
                oldX = -Math.sin(yaw) * 0.04D;
                oldZ = Math.cos(yaw) * 0.04D;
                Phase.mc.getThePlayer().setPosition(Phase.mc.getThePlayer().getPosX() + oldX, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + oldZ);
                this.tickTimer.reset();
            }
            break;

        case 1:
            if (Phase.mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && Phase.mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || Phase.mc.getThePlayer().isSneaking())) {
                yaw = MovementUtils.getDirection();
                oldX = -Math.sin(yaw) * 0.3D;
                oldZ = Math.cos(yaw) * 0.3D;

                for (i = 0; i < 3; ++i) {
                    Phase.mc.getNetHandler().addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY() + 0.06D, Phase.mc.getThePlayer().getPosZ(), true));
                    Phase.mc.getNetHandler().addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX() + oldX * (double) i, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + oldZ * (double) i, true));
                }

                Phase.mc.getThePlayer().setEntityBoundingBox(Phase.mc.getThePlayer().getEntityBoundingBox().offset(oldX, 0.0D, oldZ));
                Phase.mc.getThePlayer().setPositionAndUpdate(Phase.mc.getThePlayer().getPosX() + oldX, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + oldZ);
                this.tickTimer.reset();
            }
            break;

        case 2:
            if (Phase.mc.getThePlayer().getOnGround() && this.tickTimer.hasTimePassed(2) && Phase.mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || Phase.mc.getThePlayer().isSneaking())) {
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(0.5D, 0.0D, 0.5D, true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX(), Phase.mc.getThePlayer().getPosY() - 0.2D, Phase.mc.getThePlayer().getPosZ(), true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(0.5D, 0.0D, 0.5D, true));
                netHandlerPlayClient.addToSendQueue(Phase.classProvider.createCPacketPlayerPosition(Phase.mc.getThePlayer().getPosX() + 0.5D, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + 0.5D, true));
                yaw = Math.toRadians((double) Phase.mc.getThePlayer().getRotationYaw());
                oldX = -Math.sin(yaw) * 0.04D;
                oldZ = Math.cos(yaw) * 0.04D;
                Phase.mc.getThePlayer().setPosition(Phase.mc.getThePlayer().getPosX() + oldX, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + oldZ);
                this.tickTimer.reset();
            }
            break;

        case 3:
            if (this.tickTimer.hasTimePassed(2) && Phase.mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || Phase.mc.getThePlayer().isSneaking())) {
                yaw = Math.toRadians((double) Phase.mc.getThePlayer().getRotationYaw());
                oldX = Phase.mc.getThePlayer().getPosX();
                oldZ = Phase.mc.getThePlayer().getPosZ();

                for (i = 1; i <= 10; ++i) {
                    double x1 = -Math.sin(yaw) * (double) i;
                    double z1 = Math.cos(yaw) * (double) i;

                    if (Phase.classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(oldX + x1, Phase.mc.getThePlayer().getPosY(), oldZ + z1))) && Phase.classProvider.isBlockAir(BlockUtils.getBlock(new WBlockPos(oldX + x1, Phase.mc.getThePlayer().getPosY() + 1.0D, oldZ + z1)))) {
                        Phase.mc.getThePlayer().setPosition(oldX + x1, Phase.mc.getThePlayer().getPosY(), oldZ + z1);
                        break;
                    }
                }

                this.tickTimer.reset();
            }
            break;

        case 4:
            if (this.tickTimer.hasTimePassed(2) && Phase.mc.getThePlayer().isCollidedHorizontally() && (!isInsideBlock || Phase.mc.getThePlayer().isSneaking())) {
                yaw = Math.toRadians((double) Phase.mc.getThePlayer().getRotationYaw());
                oldX = Phase.mc.getThePlayer().getPosX();
                oldZ = Phase.mc.getThePlayer().getPosZ();
                double x = -Math.sin(yaw);
                double z = Math.cos(yaw);

                Phase.mc.getThePlayer().setPosition(oldX + x, Phase.mc.getThePlayer().getPosY(), oldZ + z);
                this.tickTimer.reset();
            }
        }

        this.tickTimer.update();
    }

    @EventTarget
    public void onBlockBB(BlockBBEvent event) {
        if (Phase.mc.getThePlayer() != null && BlockUtils.collideBlockIntersects(Phase.mc.getThePlayer().getEntityBoundingBox(), (block) -> {
            return Boolean.valueOf(!Phase.classProvider.isBlockAir(block));
        }) && event.getBoundingBox() != null && event.getBoundingBox().getMaxY() > Phase.mc.getThePlayer().getEntityBoundingBox().getMinY() && !((String) this.modeValue.get()).equalsIgnoreCase("Mineplex")) {
            IAxisAlignedBB axisAlignedBB = event.getBoundingBox();

            event.setBoundingBox(Phase.classProvider.createAxisAlignedBB(axisAlignedBB.getMaxX(), Phase.mc.getThePlayer().getEntityBoundingBox().getMinY(), axisAlignedBB.getMaxZ(), axisAlignedBB.getMinX(), axisAlignedBB.getMinY(), axisAlignedBB.getMinZ()));
        }

    }

    @EventTarget
    public void onPacket(PacketEvent event) {
        IPacket packet = event.getPacket();

        if (Phase.classProvider.isCPacketPlayer(packet)) {
            ICPacketPlayer packetPlayer = packet.asCPacketPlayer();

            if (((String) this.modeValue.get()).equalsIgnoreCase("AAC3.5.0")) {
                float yaw = (float) MovementUtils.getDirection();

                packetPlayer.setX(packetPlayer.getX() - Math.sin((double) yaw) * 1.0E-8D);
                packetPlayer.setZ(packetPlayer.getZ() + Math.cos((double) yaw) * 1.0E-8D);
            }
        }

    }

    @EventTarget
    private void onMove(MoveEvent event) {
        if (((String) this.modeValue.get()).equalsIgnoreCase("mineplex")) {
            if (Phase.mc.getThePlayer().isCollidedHorizontally()) {
                this.mineplexClip = true;
            }

            if (!this.mineplexClip) {
                return;
            }

            this.mineplexTickTimer.update();
            event.setX(0.0D);
            event.setZ(0.0D);
            if (this.mineplexTickTimer.hasTimePassed(3)) {
                this.mineplexTickTimer.reset();
                this.mineplexClip = false;
            } else if (this.mineplexTickTimer.hasTimePassed(1)) {
                double offset = this.mineplexTickTimer.hasTimePassed(2) ? 1.6D : 0.06D;
                double direction = MovementUtils.getDirection();

                Phase.mc.getThePlayer().setPosition(Phase.mc.getThePlayer().getPosX() + -Math.sin(direction) * offset, Phase.mc.getThePlayer().getPosY(), Phase.mc.getThePlayer().getPosZ() + Math.cos(direction) * offset);
            }
        }

    }

    @EventTarget
    public void onPushOut(PushOutEvent event) {
        event.cancelEvent();
    }

    public String getTag() {
        return (String) this.modeValue.get();
    }
}
